/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function() {

eval("const canvas = document.getElementById('scene1');\r\nconst c = canvas.getContext('2d');\r\ncanvas.width = 1024;\r\ncanvas.height = 576;\r\n\r\n//lets try to make battlezones\r\n\r\n///\r\n// const canvas2 = document.getElementById('scene2');\r\n// const c2 = canvas2.getContext('2d')\r\n// canvas2.width = 1024;\r\n// canvas2.height = 576;\r\n\r\n////\r\n\r\nconst battleMap = [];\r\nfor (let i = 0; i < battleTiles.length; i += 70 ) {\r\n  battleMap.push(battleTiles.slice(i, (i +70)));\r\n}\r\n\r\n\r\nconst collisionsMap = [];\r\nfor (let i = 0; i < collisions.length; i += 70) {\r\n    collisionsMap.push(collisions.slice(i, (i + 70)));\r\n}\r\nconst battleZones = [];\r\nconst boundaries = [];\r\nconst offset = {\r\n    x: -1290,\r\n    y: -600\r\n}\r\n\r\ncollisionsMap.forEach((row, i) => {\r\n    row.forEach((ele, j) => {\r\n        if (ele === 3404)\r\n        boundaries.push(\r\n        new Boundary({\r\n            position: {\r\n            x: j * Boundary.width + offset.x,\r\n            y: i * Boundary.height + offset.y\r\n        }\r\n    }))\r\n    })\r\n});\r\n\r\n\r\nbattleMap.forEach((row, i) => {\r\n  row.forEach((ele, j) => {\r\n    if (ele === 1738 )\r\n      battleZones.push(\r\n        new Zone({\r\n          position: {\r\n            x: j * Boundary.width + offset.x,\r\n            y: i * Boundary.height + offset.y\r\n          }\r\n        }))\r\n  })\r\n})\r\n\r\n\r\n\r\nconst worldmap = new Image();\r\nworldmap.src = 'wireframes\\\\map.png';\r\n\r\nconst foregroundImage = new Image();\r\nforegroundImage.src = 'wireframes\\\\foregroundObjects.png';\r\n\r\n// const knightImage = new Image ();\r\n// knightImage.src = 'wireframes\\\\down.png'\r\n\r\nconst heroDownImage = new Image () ;\r\nheroDownImage.src = 'wireframes\\\\herodown.png';\r\n\r\nconst heroUpImage = new Image () ;\r\nheroUpImage.src = 'wireframes\\\\heroup.png';\r\n\r\nconst heroLeftImage = new Image () ;\r\nheroLeftImage.src = 'wireframes\\\\heroleft.png'\r\n\r\nconst heroRightImage = new Image () ;\r\nheroRightImage.src = 'wireframes\\\\heroright.png'\r\n\r\nconst hero = new Sprite({\r\n    position: {\r\n        x: canvas.width / 2 - 128 / 4 / 2,\r\n        y: canvas.height / 2 - 48 / 2,\r\n    },\r\n    image: heroDownImage,\r\n    frames: {\r\n        max: 4\r\n    },\r\n    sprites: {\r\n        down: heroDownImage,\r\n        up: heroUpImage,\r\n        left: heroLeftImage,\r\n        right: heroRightImage\r\n    }\r\n})\r\nconsole.log(hero)\r\n// const knight = new Sprite({\r\n//     position: {\r\n//         x: canvas.width / 2 - 576 / 9 / 2,\r\n//         y: canvas.height / 2 - 64 / 2,\r\n//     },\r\n//     image: knightImage,\r\n//     frames: {\r\n//         max: 8\r\n//     }\r\n// })\r\n\r\nconst background = new Sprite({\r\n    position: {\r\n    x: offset.x,\r\n    y: offset.y\r\n    },\r\n    image: worldmap\r\n})\r\n\r\nconst foreground = new Sprite({\r\n    position: {\r\n    x: offset.x,\r\n    y: offset.y\r\n    },\r\n    image: foregroundImage\r\n})\r\n\r\nconst keys = {\r\n    w: {\r\n        pressed: false\r\n    },\r\n    a: {\r\n        pressed: false\r\n    },\r\n    s: {\r\n        pressed: false\r\n    },\r\n    d: {\r\n        pressed: false\r\n    },\r\n    c: {\r\n        pressed: false\r\n    }\r\n}\r\n\r\n\r\n\r\nconst movables = [background, ...boundaries, foreground, ...battleZones];\r\n\r\nfunction rectangularCollision({rectangle1, rectangle2}) {\r\n    return (rectangle1.position.x + rectangle1.width -8 >= rectangle2.position.x && \r\n        rectangle1.position.x <= rectangle2.position.x + rectangle2.width -10 &&\r\n        rectangle1.position.y <= rectangle2.position.y + rectangle2.height - 35 &&\r\n        rectangle1.position.y + rectangle1.height + 4 >= rectangle2.position.y)\r\n}\r\n\r\n\r\nfunction animate() {\r\n    window.requestAnimationFrame(animate);\r\n    background.draw();\r\n    boundaries.forEach(boundary => {\r\n        boundary.draw();\r\n    })\r\n    battleZones.forEach(zone => {\r\n        zone.draw();\r\n    })\r\n    // knight.draw();\r\n    hero.draw();\r\n    foreground.draw();\r\n    \r\n    let moving = true;\r\n    hero.moving = false;\r\n    //lets try battlezone activation\r\n    if (keys.c.pressed && lastKey === 'c') {\r\n      for (let i = 0; i < battleZones.length; i++) {\r\n        const zone = battleZones[i];\r\n        if (rectangularCollision({\r\n          rectangle1: hero,\r\n          rectangle2: {...zone, position : {\r\n            x: zone.position.x,\r\n            y: zone.position.y\r\n          }}\r\n        })) {\r\n          console.log(\"this is temporary placement for my code that will initite fighting scene\")\r\n          break;\r\n        }\r\n    }\r\n  }\r\n\r\n    if (keys.w.pressed && lastKey === 'w') {\r\n        hero.moving = true;\r\n        hero.image = hero.sprites.up;\r\n\r\n        for (let i =0; i < boundaries.length; i++) {\r\n            const boundary = boundaries[i];\r\n            if (rectangularCollision({\r\n                    rectangle1: hero,\r\n                    rectangle2: {...boundary, position: {\r\n                        x: boundary.position.x,\r\n                        y: boundary.position.y + 3\r\n                    }}\r\n                })) {\r\n                console.log(\"colliding\")\r\n                moving = false;\r\n                break\r\n            }\r\n        }\r\n        if (moving)\r\n        movables.forEach(movable => {\r\n            movable.position.y += 3\r\n        })\r\n    }\r\n    else if (keys.s.pressed && lastKey === 's') {\r\n        hero.moving = true;\r\n        hero.image = hero.sprites.down;\r\n\r\n        for (let i =0; i < boundaries.length; i++) {\r\n            const boundary = boundaries[i];\r\n            if (rectangularCollision({\r\n                    rectangle1: hero,\r\n                    rectangle2: {...boundary, position: {\r\n                        x: boundary.position.x,\r\n                        y: boundary.position.y - 3\r\n                    }}\r\n                })) {\r\n                console.log(\"colliding\")\r\n                moving = false;\r\n                break\r\n            }\r\n        }\r\n        if (moving)\r\n        movables.forEach(movable => {\r\n            movable.position.y -= 3\r\n        })\r\n    }\r\n    else if (keys.a.pressed && lastKey === 'a') {\r\n        hero.moving = true;\r\n        hero.image = hero.sprites.left;\r\n\r\n        for (let i =0; i < boundaries.length; i++) {\r\n            const boundary = boundaries[i];\r\n            if (rectangularCollision({\r\n                    rectangle1: hero,\r\n                    rectangle2: {...boundary, position: {\r\n                        x: boundary.position.x + 3,\r\n                        y: boundary.position.y\r\n                    }}\r\n                })) {\r\n                console.log(\"colliding\")\r\n                moving = false;\r\n                break\r\n            }\r\n        }\r\n        if (moving)\r\n        movables.forEach(movable => {\r\n            movable.position.x += 3\r\n        })\r\n    }\r\n    else if (keys.d.pressed && lastKey === 'd') {\r\n        hero.moving = true;\r\n        hero.image = hero.sprites.right;\r\n\r\n        for (let i =0; i < boundaries.length; i++) {\r\n            const boundary = boundaries[i];\r\n            if (rectangularCollision({\r\n                    rectangle1: hero,\r\n                    rectangle2: {...boundary, position: {\r\n                        x: boundary.position.x - 3,\r\n                        y: boundary.position.y \r\n                    }}\r\n                })) {\r\n                console.log(\"colliding\")\r\n                moving = false;\r\n                break\r\n            }\r\n        }\r\n        if (moving)\r\n        movables.forEach(movable => {\r\n            movable.position.x -= 3\r\n        })\r\n    }\r\n}\r\n\r\nanimate();\r\n\r\nlet lastKey = '';\r\nwindow.addEventListener('keydown', (e) => {\r\n    switch (e.key) {\r\n        case 'w':\r\n            keys.w.pressed = true;\r\n            lastKey = 'w';\r\n            break\r\n        case 'a':\r\n            keys.a.pressed = true;\r\n            lastKey = 'a';\r\n            break\r\n        case 's':\r\n            keys.s.pressed = true;\r\n            lastKey = 's';\r\n            break\r\n        case 'd':\r\n            keys.d.pressed = true;\r\n            lastKey = 'd';\r\n            break\r\n        case 'c':\r\n            keys.c.pressed = true;\r\n            lastKey = 'c';\r\n            break\r\n    }\r\n});\r\n\r\nwindow.addEventListener('keyup', (e) => {\r\n    switch (e.key) {\r\n        case 'w':\r\n            keys.w.pressed = false;\r\n            break\r\n        case 'a':\r\n            keys.a.pressed = false;\r\n            break\r\n        case 's':\r\n            keys.s.pressed = false;\r\n            break\r\n        case 'd':\r\n            keys.d.pressed = false;\r\n            break\r\n        case 'c':\r\n        keys.c.pressed = false;\r\n        break\r\n    }\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// const gravity = 0.7;\r\n\r\n// class Sprite1 {\r\n//   constructor({position, velocity}) {\r\n//     this.position = position;\r\n//     this.velocity = velocity;\r\n//     this.height = 150;\r\n//     this.lastKey\r\n//   }\r\n\r\n//   draw() {\r\n//     c2.fillStyle = 'blue';\r\n//     c2.fillRect(this.position.x, this.position.y, 50, this.height);\r\n//   }\r\n\r\n\r\n//   update() {\r\n//     this.draw();\r\n//     this.position.x += this.velocity.x;\r\n//     this.position.y += this.velocity.y;\r\n\r\n//     if (this.position.y + this.height + this.velocity.y >= canvas.height) {\r\n//       this.velocity.y = 0;\r\n//     } else {\r\n//       this.velocity.y += gravity;\r\n//     }\r\n//   }\r\n// }\r\n\r\n// const player = new Sprite1({\r\n//   position: {\r\n//   x: 100,\r\n//   y: 100\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 10\r\n//   }\r\n// });\r\n\r\n// const npc = new Sprite1({\r\n//   position: {\r\n//     x: 850,\r\n//     y: 100\r\n//   },\r\n//   velocity: {\r\n//     x: 0,\r\n//     y: 10\r\n//   }\r\n// });\r\n\r\n\r\n// console.log(player);\r\n\r\n// const keys2 = {\r\n//   a: {\r\n//     pressed: false\r\n//   },\r\n//   d: {\r\n//     pressed: false\r\n//   },\r\n//   w: {\r\n//     pressed: false\r\n//   },\r\n//   ArrowRight: {\r\n//     pressed: false\r\n//   },\r\n//   ArrowLeft: {\r\n//     pressed: false\r\n//   }\r\n// }\r\n\r\n// let lastKey2;\r\n\r\n// console.log(npc);\r\n\r\n\r\n// function animate2() {\r\n//   window.requestAnimationFrame(animate2);\r\n//   c2.fillStyle = 'black';\r\n//   c2.fillRect(0, 0, canvas2.width, canvas2.height);\r\n//   player.update();\r\n//   npc.update();\r\n\r\n//   player.velocity.x = 0;\r\n//   npc.velocity.x = 0;\r\n//   if (keys2.a.pressed && lastKey === 'a') {\r\n//     player.velocity.x = -1;\r\n//   } else if (keys2.d.pressed && lastKey === 'd') {\r\n//     player.velocity.x = 1;\r\n//   }\r\n//   ///npc movement\r\n//   if (keys2.ArrowLeft.pressed && npc.lastKey === 'ArrowLeft') {\r\n//     npc.velocity.x = -1;\r\n//   } else if (keys2.ArrowRight.pressed && npc.lastKey === 'ArrowRight') {\r\n//     npc.velocity.x = 1;\r\n//   }\r\n// }\r\n// animate2();\r\n\r\n\r\n// // const npc = new Sprite({\r\n// //   position: {\r\n// //     x: 400,\r\n// //     y: 100\r\n// //   },\r\n// //   velocity: {\r\n// //     x: 0,\r\n// //     y: 0\r\n// //   }\r\n// // });\r\n// // player.draw();\r\n// // console.log(player);\r\n\r\n\r\n// // function render() {\r\n// //   window.requestAnimationFrame(render);\r\n// //   c.fillStyle = 'black';\r\n// //   c.fillRect(0, 0, canvas.width, canvas.height)\r\n// //   player.update();\r\n// //   npc.update();\r\n\r\n// //   player.velocity.x = 0;\r\n// //   npc.velocity.x = 0;\r\n\r\n// //   if (keys.a.pressed && player.lastKey === 'a') {\r\n// //     player.velocity.x = -5;\r\n// //   } else if (keys.d.pressed && player.lastKey === 'd') {\r\n// //     player.velocity.x = 1;\r\n// //   }\r\n\r\n// //   if (keys.ArrowLeft.pressed && npc.lastKey === 'ArrowLeft') {\r\n// //     player.velocity.x = -1;\r\n// //   } else if (keys.ArrowRight.pressed && npc.lastKey === 'ArrowRight') {\r\n// //     player.velocity.x = 1;\r\n// //   }\r\n// // }\r\n\r\n// // // render();\r\n\r\n// window.addEventListener('keydown', (event) => {\r\n//   console.log(event.key);\r\n//   switch (event.key) {\r\n//     case ('d'):\r\n//       // player.velocity.x = 1;\r\n//       keys2.d.pressed = true;\r\n//       lastKey2 = 'd'\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//     case ('a'):\r\n//       // player.velocity.x = -1;\r\n//       keys2.a.pressed = true;\r\n//       lastKey2 = 'a'\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//     case ('w'):\r\n//       player.velocity.y = -10;\r\n//       break\r\n\r\n//     case ('ArrowRight'):\r\n//       // player.velocity.x = 1;\r\n//       keys2.ArrowRight.pressed = true;\r\n//       npc.lastKey2 = 'ArrowRight'\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//     case ('ArrowLeft'):\r\n//       // player.velocity.x = -1;\r\n//       keys2.ArrowLeft.pressed = true;\r\n//       npc.lastKey2 = 'ArrowLeft'\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//     case ('ArrowUp'):\r\n//       npc.velocity.y = -10;\r\n//       break\r\n//   }\r\n// })\r\n\r\n// window.addEventListener('keyup', (event) => {\r\n//   console.log(event.key);\r\n//   switch (event.key) {\r\n//     case ('d'):\r\n//       // player.velocity.x = 0;\r\n//       keys2.d.pressed = false;\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//     case ('a'):\r\n//       // player.velocity.x = 0;\r\n//       keys2.a.pressed = false;\r\n//       // player.lastKey = 'd';\r\n//       break\r\n    \r\n\r\n//       //npc\r\n//     case ('ArrowRight'):\r\n//       // player.velocity.x = 0;\r\n//       keys2.ArrowRight.pressed = false;\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//     case ('ArrowLeft'):\r\n//       // player.velocity.x = 0;\r\n//       keys2.ArrowLeft.pressed = false;\r\n//       // player.lastKey = 'd';\r\n//       break\r\n//   }\r\n// })\r\n\n\n//# sourceURL=webpack://adventurescape/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"]();
/******/ 	
/******/ })()
;